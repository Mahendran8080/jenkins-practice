## Dockerfile – Project Container Build

| Section | Description |
|---------|-------------|
| **File Purpose** | Builds a lightweight, reproducible container image that runs the Node.js application. |
| **Key Logic** | 1. **Base image** – `node:18-alpine` (small footprint, Alpine Linux). <br>2. **Working directory** – `/app` inside the container. <br>3. **Layer‑caching strategy** – `COPY package*.json ./` followed by `RUN npm install` ensures that dependency installation is cached unless the `package.json` or `package-lock.json` changes. <br>4. **Source copy** – `COPY . .` brings the rest of the application into the image. <br>5. **Port exposure** – `EXPOSE 3000` declares the listening port for container networking. <br>6. **Entrypoint** – `CMD ["node", "index.js"]` starts the application. |
| **DevOps Context** | - **CI/CD**: In a typical pipeline, this Dockerfile is used by a build step to create an image that is pushed to a registry (e.g., Docker Hub, GitHub Container Registry, or a private registry). <br>- **Deployment**: The image is then pulled by a Kubernetes deployment, Docker Compose stack, or a serverless container platform (e.g., AWS ECS, GCP Cloud Run). <br>- **Best practices**: The file follows standard Dockerfile conventions – minimal base image, explicit working directory, layer caching, and a single `CMD`. It can be extended with multi‑stage builds for production or added health‑check instructions for orchestration tools. |

> **Tip**: If you plan to use environment variables or secrets, consider adding a `.dockerignore` file to exclude `node_modules` and sensitive files, and use `ARG`/`ENV` to inject configuration at runtime.